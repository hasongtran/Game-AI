# p2 assignment. By: Trina Tran and Nathaniel Suriawijayafrom math import sqrt, inffrom heapq import heappush, heappopdef find_path(source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    distances = {}    backpointers = {}    path = []    boxes = {}    visited = {}    queued_boxes = []    detail_points = {}    temppath = []    p2p = {}    # implement helper function for the source point and destination point    source_box = id_boxes(source_point, mesh)    dest_box = id_boxes(destination_point, mesh)    detail_points[source_box] = source_point    backpointers[source_box] = None    distances[source_box] = 0    heappush(queued_boxes, (0, source_box))  # queue = [(0, source_point)]    # while queue is not empty    while queued_boxes:        if (source_box is None) or (dest_box is None):            print('No Path!')            break        # pop the source point from the queue and add it to visited nodes        totalDistance, current_node = heappop(queued_boxes)        # holds the midpoint of the first point(temp mid point to mid point)        # currentMid = midpoint(current_node)        if current_node == dest_box:            print("Match: ", current_node, dest_box)            break        # check adjacency list of box        for neighbor in mesh['adj'][current_node]:            # neighbor midpoint            adj_point = best_point(current_node, neighbor, detail_points[current_node])            # Total distance cost            current_dist = distance(adj_point, detail_points[current_node]) + totalDistance            # if distance[neighbor] DNE or the new distance is less than old distance            if neighbor not in distances or current_dist < distances[neighbor]:                detail_points[neighbor] = adj_point                p2p[neighbor, current_node] = rectify(detail_points[current_node]), rectify(adj_point)                heuristic = distance(adj_point, source_point)                distances[neighbor] = current_dist                backpointers[neighbor] = current_node                heappush(queued_boxes, (current_dist + heuristic, neighbor))  # Push onto queue    # Tracing the path    if (current_node == dest_box):        if (backpointers[current_node] == source_box):            path.append((destination_point, source_point))        else:            if (current_node == source_box):                temppath.append(dest_box)                temppath.append(source_box)            parent = backpointers[current_node]            temppath.append((dest_box, parent))            while (backpointers[current_node] != source_box):                # finding midpoints for parent box and current box                current_box = current_node                parent = backpointers[current_node]                midParent = parent                # appending the (x1,y1) (x2,y2) to path                if (current_node != dest_box):                    temppath.append((current_box, midParent))                    # path.append((midCurrent, midParent))                current_node = backpointers[current_node]                boxes[current_node] = current_box            current_box = current_node            # temppath.append((current_box, source_box))        boxes[dest_box] = destination_point        boxes[source_box] = source_point    # placing source and dest paths    if temppath:        box1, box2 = temppath[0]        box3, box4 = temppath[-1]        # print ("tp:", temppath)        # print("temp[-1]", temppath[-1])        point_s = best_point(source_box, box4, detail_points[source_box])        # print("s is", point_s)#this line is incorrect        p2p[source_box] = source_point, rectify(point_s)        point_d = best_point(box1, box2, detail_points[dest_box])        # print("d is", point_d)        p2p[dest_box] = destination_point, rectify(point_d)        # print("p2p[d]:",p2p[dest_box])        temppath.append(dest_box)        temppath.append(source_box)    for key in temppath:        path.append(p2p[key])        print("value:", p2p[key])    return path, boxes.keys()# find the midpoint of a boxdef midpoint(box):    y1, y2, x1, x2 = box    x = (x1 + x2) / 2    y = (y1 + y2) / 2    return (y, x)def rectify(point):    x, y = point    return (y, x)# Scan through the list of boxes to find which contains the source & destination pointdef id_boxes(src_point, mesh):    # set the point to the be between the box coordinates    y, x = src_point    # loops over the function to look at each box    for src_boxes in mesh['boxes']:        y1, y2, x1, x2 = src_boxes        if y1 <= y and y2 >= y and x1 <= x and x2 >= x:            return src_boxes# solves for distance between two midpointsdef distance(mp1, mp2):    dist = sqrt((mp1[0] - mp2[0]) ** 2 + (mp1[1] - mp2[1]) ** 2)    return dist# euclidean distance between point(wherever the current point is in current box) to the nearest point in next boxdef best_point(current_node, neighbor, point1):    # setting point2 to highest value for comparison    point2 = [float('inf'), float('inf')]    # setting coordinates to box points    b1y1, b1y2, b1x1, b1x2 = current_node    b2y1, b2y2, b2x1, b2x2 = neighbor    # returns the max and min for each set    x_range = [max(b1x1, b2x1), min(b1x2, b2x2)]    y_range = [max(b1y1, b2y1), min(b1y2, b2y2)]    x_val = (x_range[0] + x_range[1]) / 2    y_val = (y_range[0] + y_range[1]) / 2    point2 = (x_val, y_val)    return point2    """    # checking for nearest x coordinate to point1    for i in range(x_range[0], x_range[1]):        tmp = abs(i - point1[0])        if (tmp < point2[0]):            point2[0] = i    # checking for nearest y coordinate to point1    for i in range(y_range[0], y_range[1]):        tmp = abs(i - point1[1])        if (tmp < point2[1]):            point2[1] = i    if(x_range[0] == x_range[1]): point2[0] = x_range[0]    if(y_range[0] == y_range[1]): point2[1] = y_range[0]    return point2    """    """    minimum = float(inf)    for i in range(x_range[0], x_range[1]):        for j in range(y_range[0], y_range[1]):            tmp = distance(point1,(i,j))            print("tmp:", tmp)            if(tmp<minimum):                minimum = tmp                point2=[i,j]    if(x_range[0] == x_range[1]): point2[0] = x_range[0]    if(y_range[0] == y_range[1]): point2[1] = y_range[0]    """    # return euclidean(point1, point2)